# skip_2 = sum(skip_2),
# skip_3 = sum(skip_3),
not_skipped = sum(not_skipped)
) %>%
# Take only the tracks played 50 or more times.
filter(plays >= 50) %>%
# Add percentage of times each was not skipped of its total times played.
mutate(not_skipped_pct = not_skipped / plays)
# Join features to plays_skips.
track_plays_skips_features <- track_plays_and_skips %>%
left_join(track_features, by = c("track_id_clean" = "track_id"))
# Drop least skipped dataframe to keep only desired column variables.
# Note quotes are required around objects to call columns by name in this format.
# Note: let's keep "not_skipped_pct" which in ggplot2 and ggiraph we can call column as our tooltip aesthetic for hover or on click display in Shiny.
# Note: let's keep "track_id_clean" as our required data_id aesthetic for use with ggplot2 and ggiraph interactivity and because we want this as input for Spotify Developer API engpoints later.
drop <- c("plays",
#"skip_1",
#"skip_2",
#"skip_3",
"not_skipped","dyn_range_mean","mode","acoustic_vector_0","acoustic_vector_1","acoustic_vector_2","acoustic_vector_3","acoustic_vector_4","acoustic_vector_5","acoustic_vector_6","acoustic_vector_7",
# I will also drop the features not on a 0-1 scale for this interactive ggplot ggradar chart since otherwise we would need to rescale them to 0-1 and it would appear inaccurate I think.
"us_popularity_est", "release_year", "duration", "time_signature", "tempo", "key", "loudness")
track_plays_skips_features1 = track_plays_skips_features[,!(names(track_plays_skips_features) %in% drop)]
# I just want to see the row names quick, which indeed are auto-generated sequential numbers.
#row.names(track_plays_skips_features1)
# Rename track ID as a column named group for ggradar.
track_plays_skips_features1 <- track_plays_skips_features1 %>%
rename(
group = track_id_clean
)
# Add min and max to data frame as first 2 rows for range.
# Commented out because this was the requirement for radar chart with fmsb package; ggplot2 uses a single scale assigned grid.min and grid.max
# max_min <- data.frame(
#   duration = c(2000.0, 0.0), release_year = c(2021, 1950), us_popularity_estimate = c(100.0, 0.0), acousticness = c(1.0, 0.0), beat_strength = c(1.0, 0.0), bounciness =  c(1.0, 0.0), danceability = c(1.0, 0.0), energy = c(1.0, 0.0), flatness = c(1.0, 0.0), instrumentalness = c(1.0, 0.0), key = c(11, 0), liveness = c(1.0, 0.0), loudness = c(-60.0, 0.0), mechanism = c(1.0, 0.0), organism = c(1.0, 0.0), speechiness = c(1.0, 0.0), tempo = c(220.0, 0.0), time_signature = c(5, 0), valence = c(1.0, 0.0)
# )
# rownames(max_min) <- c("Max", "Min")
# # Bind the variable ranges to the data.
# tracks_plays_skips_radar <- rbind(max_min, track_plays_skips_features1)
# Adjust the columns order for a more visually effective radar chart.
col_order <- c("group","not_skipped_pct",
# omit dropped columns due to scale besided 0-1 for now.
#"us_popularity_estimate", "release_year", "duration", "time_signature", "tempo", "key", "loudness",
"acousticness", "beat_strength", "bounciness", "danceability", "liveness", "mechanism", "organism", "energy", "flatness", "instrumentalness", "speechiness", "valence")
tracks_plays_skips_radar2 <- track_plays_skips_features1[, col_order]
# Isolate the least skipped tracks.
tracks_least_skipped_radar <- tail(tracks_plays_skips_radar2)
tracks_least_skipped_radar
# Isolate most skipped tracks.
# Most skipped commented out with fmsb package radarchart in debugging to troubleshoot Warning: Error in writeImpl: Text to be written must be a length-one character vector [No stack trace available]
#tracks_most_skipped_radar <- head(tracks_plays_skips_radar2)
#tracks_most_skipped_features
# Define UI for application
ui <- fluidPage(titlePanel("Sell Out Music Listener"),
fluidRow(
column(width = 4,
plotOutput("plot1", height = 300,
# Equivalent to: click = clickOpts(id = "plot_click")
click = "plot1_click",
brush = brushOpts(
id = "plot1_brush"
)
)
)
),
fluidRow(
column(width = 6,
h4("Points near click"),
verbatimTextOutput("click_info")
),
column(width = 6,
h4("Brushed points"),
verbatimTextOutput("brush_info")
)
)
)
server <- function(input, output) {
output$plot1 <- renderPlot({
# First we will get the least skipped working in ggradar, and then we may return to plot the comparison most skipped beside it
# Now we will plot the least and most skipped charts beside one another for comparison.
#opar <- par()
# Define settings for plotting in a 1x2 (2 column) grid, with appropriate margins:
#par(mar = rep(.8,4)) #may require testing to get margins between plots looking good
#par(mfrow = c(1,2)) # 1 row, 2 columns
# Produce a radar-chart for each desired plot again, least skipped at left; most to right
# Customized least skipped radar chart
ggradar(
tracks_least_skipped_radar,
# Add a plot title.
plot.title = "Features of Least Skipped Spotify Tracks",
# Custom labels (removed for now any audio feature columns not on 0-1 scale: "US Popularity est. %", "Release Year", "Duration (ms)", "Time Signature", "Tempo", "Key", "Loudness", )
axis.labels = c("Acousticness", "Beat Strength", "Bounciness", "Danceability", "Liveness", "Mechanism", "Organism", "Energy", "Flatness", "Instrumentalness", "Speechiness", "Valence"),
axis.label.size = 0.8,
# We could offset the axis labels further away from the max circle if they appear crowded, measured relative to circle diameter.
#axis.label.offset = 2 # We'll test the default 1.15 first.
# Note ggradar does not appear to have an axis color option, as we used "grey30" in fmsb (i.e. axislabcol = "grey30").
values.radar = c("0", "0.5", "1"),
# Grid line values (3 lines drawn)
grid.min = 0, grid.mid = 0.5, grid.max = 1,
# Polygons
group.line.width = 0.8,
group.point.size = 3,
# Colors the lines of the polygon(s), let's generalize all of these 'good' i.e. least skipped as a similar range of color using a R palette, since we'll compare it to 'bad' most skipped, not among themselves as much.
group.colours = palette_greens,
# Adds same colors as fill to polygons with more transparency (not clear yet how to convert this from fmsb to ggradar).
#pfcol = palette_greens_in,
# Background and grid lines (types and colors)
background.circle.colour = "white", # Note, default is yellow in ggradar.
grid.line.width = 0.8,
gridline.min.linetype = "solid",
gridline.mid.linetype = "solid",
gridline.max.linetype = "solid", # Note, default is long dashed line in ggradar.
# Note the min and max lines' color defaults are grey so we don't have to state them.
gridline.mid.colour = "grey", # Default for the mid point line is blue, which I would find distracting in this case.
# No legend desired.
plot.legend = FALSE,
# Legend position (probably don't want a legend showing Track ID; we're concerned with these as a visual group of least skipped with some variation.)
#legend.position = "bottom",
# How do we make this interactive now...
# interactive = TRUE
)
runApp('Sell-Out-Music')
shiny::runApp('Sell-Out-Music')
rlang::last_error()
rlang::last_trace()
skips %>%
count(track_id_clean) %>%
arrange(desc(n))
# sample data subset; add percent not skipped
track_plays_and_skips <- skips %>%
group_by(track_id_clean) %>%
summarise(
plays = n(),
# skip_1 = sum(skip_1),
# skip_2 = sum(skip_2),
# skip_3 = sum(skip_3),
not_skipped = sum(not_skipped)
) %>%
# Take only the tracks played 50 or more times.
filter(plays >= 50) %>%
# Add percentage of times each was not skipped of its total times played.
mutate(not_skipped_pct = not_skipped / plays)
# Join features to plays_skips.
track_plays_skips_features <- track_plays_and_skips %>%
left_join(track_features, by = c("track_id_clean" = "track_id"))
# Drop least skipped dataframe to keep only desired column variables.
# Note quotes are required around objects to call columns by name in this format.
# Note: let's keep "not_skipped_pct" which in ggplot2 and ggiraph we can call column as our tooltip aesthetic for hover or on click display in Shiny.
# Note: let's keep "track_id_clean" as our required data_id aesthetic for use with ggplot2 and ggiraph interactivity and because we want this as input for Spotify Developer API engpoints later.
drop <- c("plays",
#"skip_1",
#"skip_2",
#"skip_3",
# drop not_skipped_pct for now but ideally it could be in a tooltip later.
"not_skipped_pct",
"not_skipped","dyn_range_mean","mode","acoustic_vector_0","acoustic_vector_1","acoustic_vector_2","acoustic_vector_3","acoustic_vector_4","acoustic_vector_5","acoustic_vector_6","acoustic_vector_7",
# I will also drop the features not on a 0-1 scale for this interactive ggplot ggradar chart since otherwise we would need to rescale them to 0-1 and it would appear inaccurate I think.
"us_popularity_est", "release_year", "duration", "time_signature", "tempo", "key", "loudness")
track_plays_skips_features1 = track_plays_skips_features[,!(names(track_plays_skips_features) %in% drop)]
# Adjust the columns order for a more visually effective radar chart.
col_order <- c("track_id_clean",# for now ignore: "not_skipped_pct", #(would like to add back in as a tooltip, but it's erroring out because we're not plotting it on radar)
# omit dropped columns due to scale besided 0-1 for now.
#"us_popularity_estimate", "release_year", "duration", "time_signature", "tempo", "key", "loudness",
"acousticness", "beat_strength", "bounciness", "danceability", "liveness", "mechanism", "organism", "energy", "flatness", "instrumentalness", "speechiness", "valence")
tracks_plays_skips_radar2 <- track_plays_skips_features1[, col_order]
# Assign row names from 1st column, which contains "track_id_clean". This will not be plotted on radar chart, and will become group later.
rownames(tracks_plays_skips_radar2) <- tracks_plays_skips_radar2[,1]
# Now that track_id_clean are the rownames, drop it from the columns.
tracks_plays_skips_radar2[,1] <- NULL
tracks_plays_skips_radar2
# I just want to see the row names quick to confirm.
row.names(tracks_plays_skips_radar2)
tracks_plays_skips_radar2
shiny::runApp('Sell-Out-Music')
# Check the row names at this point.
rownames(tracks_plays_skips_radar2)
rownames(tracks_plays_skips_radar2) <- tracks_plays_skips_radar2[,1]
tracks_plays_skips_radar2[,1]
tracks_plays_skips_radar2$track_id_clean
glimpse(tracks_plays_skips_radar2)
track_plays_and_skips
track_plays_skips_features
drop
track_plays_skips_features1
tracks_plays_skips_radar2
col_order <- c("track_id_clean", "acousticness", "beat_strength", "bounciness", "danceability", "liveness", "mechanism", "organism", "energy", "flatness", "instrumentalness", "speechiness", "valence")
tracks_plays_skips_radar2 <- track_plays_skips_features1[, col_order]
# Check the row names at this point.
#rownames(tracks_plays_skips_radar2)
# For debugging, check to see if track_id_clean displays here.
tracks_plays_skips_radar2
col_order <- c("track_id_clean", "acousticness", "beat_strength", "bounciness", "danceability", "liveness", "mechanism", "organism", "energy", "flatness", "instrumentalness", "speechiness", "valence")
tracks_plays_skips_radar2 <- track_plays_skips_features1[, col_order]
# Check the row names at this point.
#rownames(tracks_plays_skips_radar2)
# For debugging, check to see if track_id_clean displays here.
tracks_plays_skips_radar2
tracks_plays_skips_radar2$track_id_clean
tracks_plays_skips_radar2[,1]
glimpse(tracks_plays_skips_radar2)
rownames(tracks_plays_skips_radar2) <- tracks_plays_skips_radar2[,1]
# Now that track_id_clean are the rownames, drop it from the columns.
tracks_plays_skips_radar2[,1] <- NULL
tracks_plays_skips_radar2
rownames(tracks_plays_skips_radar2) <- tracks_plays_skips_radar2[,1]
tracks_plays_skips_radar2[,1]
row.names(tracks_plays_skips_radar2)
skips %>%
count(track_id_clean) %>%
arrange(desc(n))
# sample data subset; add percent not skipped
track_plays_and_skips <- skips %>%
group_by(track_id_clean) %>%
summarise(
plays = n(),
# skip_1 = sum(skip_1),
# skip_2 = sum(skip_2),
# skip_3 = sum(skip_3),
not_skipped = sum(not_skipped)
) %>%
# Take only the tracks played 50 or more times.
filter(plays >= 50) %>%
# Add percentage of times each was not skipped of its total times played.
mutate(not_skipped_pct = not_skipped / plays)
# For debugging, check to see if track_id_clean displays here.
#track_plays_and_skips
# Join features to plays_skips.
track_plays_skips_features <- track_plays_and_skips %>%
left_join(track_features, by = c("track_id_clean" = "track_id"))
# For debugging, check to see if track_id_clean displays here.
#track_plays_skips_features
# Drop least skipped dataframe to keep only desired column variables.
# Note quotes are required around objects to call columns by name in this format.
# Note: let's keep "not_skipped_pct" which in ggplot2 and ggiraph we can call column as our tooltip aesthetic for hover or on click display in Shiny.
# Note: let's keep "track_id_clean" as our required data_id aesthetic for use with ggplot2 and ggiraph interactivity and because we want this as input for Spotify Developer API engpoints later.
drop <- c("plays",
#"skip_1",
#"skip_2",
#"skip_3",
# drop not_skipped_pct for now but ideally it could be in a tooltip later.
"not_skipped_pct",
"not_skipped","dyn_range_mean","mode","acoustic_vector_0","acoustic_vector_1","acoustic_vector_2","acoustic_vector_3","acoustic_vector_4","acoustic_vector_5","acoustic_vector_6","acoustic_vector_7",
# I will also drop the features not on a 0-1 scale for this interactive ggplot ggradar chart since otherwise we would need to rescale them to 0-1 and it would appear inaccurate I think.
"us_popularity_est", "release_year", "duration", "time_signature", "tempo", "key", "loudness")
track_plays_skips_features1 = track_plays_skips_features[,!(names(track_plays_skips_features) %in% drop)]
# For debugging, check to see if track_id_clean displays here.
#track_plays_skips_features1
# Adjust the columns order for a more visually effective radar chart.
# for now ignore: "not_skipped_pct", #(would like to add back in as a tooltip, but it's erroring out because we're not plotting it on radar)
# omit dropped columns due to scale besided 0-1 for now.
#"us_popularity_estimate", "release_year", "duration", "time_signature", "tempo", "key", "loudness",
col_order <- c("track_id_clean", "acousticness", "beat_strength", "bounciness", "danceability", "liveness", "mechanism", "organism", "energy", "flatness", "instrumentalness", "speechiness", "valence")
tracks_plays_skips_radar2 <- track_plays_skips_features1[, col_order]
# For debugging, check the row names at this point.
#rownames(tracks_plays_skips_radar2)
# For debugging, check to see if track_id_clean displays here.
#tracks_plays_skips_radar2
# For debugging, check the first column in dataframe. We want it to be the track ID.
tracks_plays_skips_radar2[,1]
# Assign row names from 1st column, which contains "track_id_clean". This will not be plotted on radar chart, and will become group later.
rownames(tracks_plays_skips_radar2) <- tracks_plays_skips_radar2[,1]
# Now that track_id_clean are the rownames, drop it from the columns.
#tracks_plays_skips_radar2[,1] <- NULL
tracks_plays_skips_radar2
rownames(tracks_plays_skips_radar2) <- tracks_plays_skips_radar2[,1]
library(magrittr)
tracks_plays_skips_radar2 %>% data.frame %>% set_rownames(.$x1) %>% select(-x1)
tracks_plays_skips_radar2 %>% data.frame %>% set_rownames(.$track_id_clean) %>% select(-track_id_clean)
tracks_plays_skips_radar2
tracks_plays_skips_radar2 %>% data.frame %>% set_rownames(.$track_id_clean) %>% select(-track_id_clean)
tracks_plays_skips_radar2 <-tracks_plays_skips_radar2 %>% data.frame %>% set_rownames(.$track_id_clean) %>% select(-track_id_clean)
tracks_plays_skips_radar2
tracks_plays_skips_radar2.head()
glimpse(tracks_plays_skips_radar2)
head(tracks_plays_skips_radar2)
row.names(tracks_plays_skips_radar2)
# Isolate the least skipped tracks.
tracks_least_skipped_radar <- tracks_plays_skips_radar2 %>%
rownames = "group" %>%
mutate_at(vars(-group), rescale) %>%
tail() %>%
select(1:13)
tracks_least_skipped_radar
# Isolate most skipped tracks.
# Most skipped commented out with fmsb package radarchart in debugging to troubleshoot Warning: Error in writeImpl: Text to be written must be a length-one character vector [No stack trace available]
#tracks_most_skipped_radar <- head(tracks_plays_skips_radar2)
#tracks_most_skipped_features
# Define UI for application
ui <- fluidPage(titlePanel("Sell Out Music Listener"),
fluidRow(
column(width = 4,
plotOutput("plot1", height = 300,
# Equivalent to: click = clickOpts(id = "plot_click")
click = "plot1_click",
brush = brushOpts(
id = "plot1_brush"
)
)
)
),
fluidRow(
column(width = 6,
h4("Points near click"),
verbatimTextOutput("click_info")
),
column(width = 6,
h4("Brushed points"),
verbatimTextOutput("brush_info")
)
)
)
server <- function(input, output) {
output$plot1 <- renderPlot({
# First we will get the least skipped working in ggradar, and then we may return to plot the comparison most skipped beside it
# Now we will plot the least and most skipped charts beside one another for comparison.
#opar <- par()
# Define settings for plotting in a 1x2 (2 column) grid, with appropriate margins:
#par(mar = rep(.8,4)) #may require testing to get margins between plots looking good
#par(mfrow = c(1,2)) # 1 row, 2 columns
# Produce a radar-chart for each desired plot again, least skipped at left; most to right
# Customized least skipped radar chart
ggradar(
tracks_least_skipped_radar,
# Add a plot title.
plot.title = "Features of Least Skipped Spotify Tracks",
# Custom labels (removed for now any audio feature columns not on 0-1 scale: "US Popularity est. %", "Release Year", "Duration (ms)", "Time Signature", "Tempo", "Key", "Loudness", )
axis.labels = c("Acousticness", "Beat Strength", "Bounciness", "Danceability", "Liveness", "Mechanism", "Organism", "Energy", "Flatness", "Instrumentalness", "Speechiness", "Valence"),
axis.label.size = 0.8,
# We could offset the axis labels further away from the max circle if they appear crowded, measured relative to circle diameter.
#axis.label.offset = 2 # We'll test the default 1.15 first.
# Note ggradar does not appear to have an axis color option, as we used "grey30" in fmsb (i.e. axislabcol = "grey30").
values.radar = c("0", "0.5", "1"),
# Grid line values (3 lines drawn)
grid.min = 0, grid.mid = 0.5, grid.max = 1,
# Polygons
group.line.width = 0.8,
group.point.size = 3,
# Colors the lines of the polygon(s), let's generalize all of these 'good' i.e. least skipped as a similar range of color using a R palette, since we'll compare it to 'bad' most skipped, not among themselves as much.
group.colours = palette_greens,
# Adds same colors as fill to polygons with more transparency (not clear yet how to convert this from fmsb to ggradar).
#pfcol = palette_greens_in,
# Background and grid lines (types and colors)
background.circle.colour = "white", # Note, default is yellow in ggradar.
grid.line.width = 0.8,
gridline.min.linetype = "solid",
gridline.mid.linetype = "solid",
gridline.max.linetype = "solid", # Note, default is long dashed line in ggradar.
# Note the min and max lines' color defaults are grey so we don't have to state them.
gridline.mid.colour = "grey", # Default for the mid point line is blue, which I would find distracting in this case.
# No legend desired.
plot.legend = FALSE,
# Legend position (probably don't want a legend showing Track ID; we're concerned with these as a visual group of least skipped with some variation.)
#legend.position = "bottom",
# Can we make this interactive now...
# interactive = TRUE
)
# Customized most skipped radar chart
# How do we render a plot2? It would be good to show the visual comparison even if we don't program interaction with its points in the same way as with the least skipped plot1.
# Most skipped commented out in debugging to troubleshoot Warning: Error in writeImpl: Text to be written must be a length-one character vector [No stack trace available]
#     radarchart(tracks_most_skipped_radar, axistype = 3,
#            #add a title
#            title = "Features of Most Skipped Spotify Tracks",
#            #custom polygon, let's generalize all of these 'bad' i.e. most skipped as a similar range of color using a R palette, less emphasis than the greens were for 'good' tracks, since we'll compare it to 'good' least skipped, not among themselves as much.
#            #colors the lines
#            pcol = palette_greys,
#            #adds same colors as fill to polygons
#            pfcol = palette_greys_in,
#
#            #custom the grid; we will test greys on grey grid and adjust if needed.
#            cglcol = "grey", cglty = 1, axislabcol = "grey30", cglwd = 0.8,
#
#            #custom labels
#            vlabels=c("US Popularity est. %", "Release Year", "Duration (ms)", "Time Signature", "Tempo", "Key", "Loudness", "Acousticness", "Beat Strength", "Bounciness", "Danceability", "Liveness", "Mechanism", "Organism", "Energy", "Flatness", "Instrumentalness", "Speechiness", "Valence"),
#            vlcex = 0.635,
#            #plot just a zero in center because all scales share min as 0
#            caxislabels=c("0", "", "", "", "")
# )
# Restore the standard par() settings
#    par <- par(opar)
})
# How can I supply xvar for my radar chart? (For points, it could be any of: xvar = c("us_popularity_estimate", "release_year", "duration", "time_signature", "tempo", "key", "loudness", "acousticness", "beat_strength", "bounciness", "danceability", "liveness", "mechanism", "organism", "energy", "flatness", "instrumentalness", "speechiness", "valence"])
output$click_info <- renderPrint({
# Because radarchart is not a ggplot2 (which would not require us to supply xvar or yvar); if this
# were a base graphics plot, we'd need those. Radar Chart is made in fmsb so to troubleshoot "Error in nearPoints: nearPoints: not able to automatically infer `xvar` from coordinfo",
# let's try to to explicitly supply xvar and yvar, which are multiples for many radar axes.
# Shiny nearpoints docs at: https://shiny.rstudio.com/reference/shiny/0.12.0/nearPoints.html
nearPoints(tracks_least_skipped_radar2, input$plot1_click, addDist = TRUE)
})
output$brush_info <- renderPrint({
brushedPoints(tracks_least_skipped_radar2, input$plot1_brush)
})
}
# Run the application.
shinyApp(ui, server)
# Isolate the least skipped tracks.
tracks_least_skipped_radar <- tracks_plays_skips_radar2 %>%
rownames = "group" %>%
mutate_at(vars(-group), rescale) %>%
tail() %>%
select(1:12)
tracks_least_skipped_radar
# Isolate most skipped tracks.
# Most skipped commented out with fmsb package radarchart in debugging to troubleshoot Warning: Error in writeImpl: Text to be written must be a length-one character vector [No stack trace available]
#tracks_most_skipped_radar <- head(tracks_plays_skips_radar2)
#tracks_most_skipped_features
# Define UI for application
ui <- fluidPage(titlePanel("Sell Out Music Listener"),
fluidRow(
column(width = 4,
plotOutput("plot1", height = 300,
# Equivalent to: click = clickOpts(id = "plot_click")
click = "plot1_click",
brush = brushOpts(
id = "plot1_brush"
)
)
)
),
fluidRow(
column(width = 6,
h4("Points near click"),
verbatimTextOutput("click_info")
),
column(width = 6,
h4("Brushed points"),
verbatimTextOutput("brush_info")
)
)
)
server <- function(input, output) {
output$plot1 <- renderPlot({
# First we will get the least skipped working in ggradar, and then we may return to plot the comparison most skipped beside it
# Now we will plot the least and most skipped charts beside one another for comparison.
#opar <- par()
# Define settings for plotting in a 1x2 (2 column) grid, with appropriate margins:
#par(mar = rep(.8,4)) #may require testing to get margins between plots looking good
#par(mfrow = c(1,2)) # 1 row, 2 columns
# Produce a radar-chart for each desired plot again, least skipped at left; most to right
# Customized least skipped radar chart
ggradar(
tracks_least_skipped_radar,
# Add a plot title.
plot.title = "Features of Least Skipped Spotify Tracks",
# Custom labels (removed for now any audio feature columns not on 0-1 scale: "US Popularity est. %", "Release Year", "Duration (ms)", "Time Signature", "Tempo", "Key", "Loudness", )
axis.labels = c("Acousticness", "Beat Strength", "Bounciness", "Danceability", "Liveness", "Mechanism", "Organism", "Energy", "Flatness", "Instrumentalness", "Speechiness", "Valence"),
axis.label.size = 0.8,
# We could offset the axis labels further away from the max circle if they appear crowded, measured relative to circle diameter.
#axis.label.offset = 2 # We'll test the default 1.15 first.
# Note ggradar does not appear to have an axis color option, as we used "grey30" in fmsb (i.e. axislabcol = "grey30").
values.radar = c("0", "0.5", "1"),
# Grid line values (3 lines drawn)
grid.min = 0, grid.mid = 0.5, grid.max = 1,
# Polygons
group.line.width = 0.8,
group.point.size = 3,
# Colors the lines of the polygon(s), let's generalize all of these 'good' i.e. least skipped as a similar range of color using a R palette, since we'll compare it to 'bad' most skipped, not among themselves as much.
group.colours = palette_greens,
# Adds same colors as fill to polygons with more transparency (not clear yet how to convert this from fmsb to ggradar).
#pfcol = palette_greens_in,
# Background and grid lines (types and colors)
background.circle.colour = "white", # Note, default is yellow in ggradar.
grid.line.width = 0.8,
gridline.min.linetype = "solid",
gridline.mid.linetype = "solid",
gridline.max.linetype = "solid", # Note, default is long dashed line in ggradar.
# Note the min and max lines' color defaults are grey so we don't have to state them.
gridline.mid.colour = "grey", # Default for the mid point line is blue, which I would find distracting in this case.
# No legend desired.
plot.legend = FALSE,
# Legend position (probably don't want a legend showing Track ID; we're concerned with these as a visual group of least skipped with some variation.)
#legend.position = "bottom",
# Can we make this interactive now...
# interactive = TRUE
)
# Customized most skipped radar chart
# How do we render a plot2? It would be good to show the visual comparison even if we don't program interaction with its points in the same way as with the least skipped plot1.
# Most skipped commented out in debugging to troubleshoot Warning: Error in writeImpl: Text to be written must be a length-one character vector [No stack trace available]
#     radarchart(tracks_most_skipped_radar, axistype = 3,
#            #add a title
#            title = "Features of Most Skipped Spotify Tracks",
#            #custom polygon, let's generalize all of these 'bad' i.e. most skipped as a similar range of color using a R palette, less emphasis than the greens were for 'good' tracks, since we'll compare it to 'good' least skipped, not among themselves as much.
#            #colors the lines
#            pcol = palette_greys,
#            #adds same colors as fill to polygons
#            pfcol = palette_greys_in,
#
#            #custom the grid; we will test greys on grey grid and adjust if needed.
#            cglcol = "grey", cglty = 1, axislabcol = "grey30", cglwd = 0.8,
#
#            #custom labels
#            vlabels=c("US Popularity est. %", "Release Year", "Duration (ms)", "Time Signature", "Tempo", "Key", "Loudness", "Acousticness", "Beat Strength", "Bounciness", "Danceability", "Liveness", "Mechanism", "Organism", "Energy", "Flatness", "Instrumentalness", "Speechiness", "Valence"),
#            vlcex = 0.635,
#            #plot just a zero in center because all scales share min as 0
#            caxislabels=c("0", "", "", "", "")
# )
# Restore the standard par() settings
#    par <- par(opar)
})
# How can I supply xvar for my radar chart? (For points, it could be any of: xvar = c("us_popularity_estimate", "release_year", "duration", "time_signature", "tempo", "key", "loudness", "acousticness", "beat_strength", "bounciness", "danceability", "liveness", "mechanism", "organism", "energy", "flatness", "instrumentalness", "speechiness", "valence"])
output$click_info <- renderPrint({
# Because radarchart is not a ggplot2 (which would not require us to supply xvar or yvar); if this
# were a base graphics plot, we'd need those. Radar Chart is made in fmsb so to troubleshoot "Error in nearPoints: nearPoints: not able to automatically infer `xvar` from coordinfo",
# let's try to to explicitly supply xvar and yvar, which are multiples for many radar axes.
# Shiny nearpoints docs at: https://shiny.rstudio.com/reference/shiny/0.12.0/nearPoints.html
nearPoints(tracks_least_skipped_radar2, input$plot1_click, addDist = TRUE)
})
output$brush_info <- renderPrint({
brushedPoints(tracks_least_skipped_radar2, input$plot1_brush)
})
}
# Run the application.
shinyApp(ui, server)
runApp('Sell-Out-Music')
