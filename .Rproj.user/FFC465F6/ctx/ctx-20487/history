track_features <- read_csv("../data/raw/track_features/tf_mini.csv")
skips <- read_csv("../data/raw/training_set/log_mini.csv")
# counts of number of times each track (by ID) appears in training dataset and sort table by counts descending
skips %>%
count(track_id_clean) %>%
arrange(desc(n))
# sample data subset; add percent not skipped
track_plays_and_skips <- skips %>%
group_by(track_id_clean) %>%
summarise(
plays = n(),
skip_1 = sum(skip_1),
skip_2 = sum(skip_2),
skip_3 = sum(skip_3),
not_skipped = sum(not_skipped)
) %>%
# Take only the tracks played 50 or more times.
filter(plays >= 50) %>%
# Add percentage of times each was not skipped of its total times played.
mutate(not_skipped_pct = not_skipped / plays)
# Join features to plays_skips.
track_plays_skips_features <- track_plays_and_skips %>%
left_join(track_features, by = c("track_id_clean" = "track_id"))
# Drop least skipped dataframe to keep only desired column variables.
# Note quotes are required around objects to call columns by name in this format.
# Note: let's keep "not_skipped_pct" which in ggplot2 and ggiraph we can call column as our tooltip aesthetic for hover or on click display in Shiny.
# Note: let's keep "track_id_clean" as our required data_id aesthetic for use with ggplot2 and ggiraph interactivity and because we want this as input for Spotify Developer API engpoints later.
drop <- c("plays","skip_1","skip_2","skip_3","not_skipped","dyn_range_mean","mode","acoustic_vector_0","acoustic_vector_1","acoustic_vector_2","acoustic_vector_3","acoustic_vector_4","acoustic_vector_5","acoustic_vector_6","acoustic_vector_7")
track_plays_skips_features1 = track_plays_skips_features[,!(names(track_plays_skips_features) %in% drop)]
# I just want to check the row names.
#row.names(track_plays_skips_features1)
# Rename track ID as a column named group for ggradar.
track_plays_skips_features1 %>%
rename(
group = track_id_clean
)
#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
# Load packages
# Note quotes used in install of some packages below, becuase those otherwise would error and cannot be found and in RStudio packages list
library(shiny)
#library(ggplot2)
#devtools::install_github("ricardo-bion/ggradar")
library("ggradar")
library(scales)
#install.packages("ggiraph")
library("ggiraph")
library("moonBook")
library(sjmisc)
library(reshape2)
#install.packages("Cairo"),
#library(Cairo) # For nicer ggplot2 output when deployed on Linux
library(tidyverse)
#library(dplyr)
#loaded this explicitly in addition to tidyverse on recommendation that sometimes pipe won't work with tidyversy loaded alone, although package is included with tidyverse.
library(lubridate)
library(sf)
library(leaflet)
library(htmltools)
library(DT)
#install.packages("fmsb")
#library(fmsb) #commented out due to rewriting radarchart in ggplot2, ggiraph
library(RColorBrewer)
# Load data
# We'll use only plotted subset of the data set and columns
# so that it prints nicely
# Load data from .csv files.
track_features <- read_csv("../data/raw/track_features/tf_mini.csv")
skips <- read_csv("../data/raw/training_set/log_mini.csv")
# counts of number of times each track (by ID) appears in training dataset and sort table by counts descending
skips %>%
count(track_id_clean) %>%
arrange(desc(n))
# sample data subset; add percent not skipped
track_plays_and_skips <- skips %>%
group_by(track_id_clean) %>%
summarise(
plays = n(),
# skip_1 = sum(skip_1),
# skip_2 = sum(skip_2),
# skip_3 = sum(skip_3),
not_skipped = sum(not_skipped)
) %>%
# Take only the tracks played 50 or more times.
filter(plays >= 50) %>%
# Add percentage of times each was not skipped of its total times played.
mutate(not_skipped_pct = not_skipped / plays)
# Join features to plays_skips.
track_plays_skips_features <- track_plays_and_skips %>%
left_join(track_features, by = c("track_id_clean" = "track_id"))
# Drop least skipped dataframe to keep only desired column variables.
# Note quotes are required around objects to call columns by name in this format.
# Note: let's keep "not_skipped_pct" which in ggplot2 and ggiraph we can call column as our tooltip aesthetic for hover or on click display in Shiny.
# Note: let's keep "track_id_clean" as our required data_id aesthetic for use with ggplot2 and ggiraph interactivity and because we want this as input for Spotify Developer API engpoints later.
drop <- c("plays",
#"skip_1",
#"skip_2",
#"skip_3",
"not_skipped","dyn_range_mean","mode","acoustic_vector_0","acoustic_vector_1","acoustic_vector_2","acoustic_vector_3","acoustic_vector_4","acoustic_vector_5","acoustic_vector_6","acoustic_vector_7",
# I will also drop the features not on a 0-1 scale for this interactive ggplot ggradar chart since otherwise we would need to rescale them to 0-1 and it would appear inaccurate I think.
"us_popularity_est", "release_year", "duration", "time_signature", "tempo", "key", "loudness")
track_plays_skips_features1 = track_plays_skips_features[,!(names(track_plays_skips_features) %in% drop)]
# I just want to see the row names quick, which indeed are auto-generated sequential numbers.
#row.names(track_plays_skips_features1)
# Rename track ID as a column named group for ggradar.
track_plays_skips_features1 %>%
rename(
group = track_id_clean
)
# Add min and max to data frame as first 2 rows for range.
max_min <- data.frame(
duration = c(2000.0, 0.0), release_year = c(2021, 1950), us_popularity_estimate = c(100.0, 0.0), acousticness = c(1.0, 0.0), beat_strength = c(1.0, 0.0), bounciness =  c(1.0, 0.0), danceability = c(1.0, 0.0), energy = c(1.0, 0.0), flatness = c(1.0, 0.0), instrumentalness = c(1.0, 0.0), key = c(11, 0), liveness = c(1.0, 0.0), loudness = c(-60.0, 0.0), mechanism = c(1.0, 0.0), organism = c(1.0, 0.0), speechiness = c(1.0, 0.0), tempo = c(220.0, 0.0), time_signature = c(5, 0), valence = c(1.0, 0.0)
)
rownames(max_min) <- c("Max", "Min")
# Bind the variable ranges to the data.
tracks_plays_skips_radar <- rbind(max_min, track_plays_skips_features1)
# Adjust the columns order for a more visually effective radar chart.
col_order <- c("track_id_clean","not_skipped_pct",
# omit dropped columns due to scale besided 0-1 for now.
#"us_popularity_estimate", "release_year", "duration", "time_signature", "tempo", "key", "loudness",
"acousticness", "beat_strength", "bounciness", "danceability", "liveness", "mechanism", "organism", "energy", "flatness", "instrumentalness", "speechiness", "valence")
tracks_plays_skips_radar2 <- tracks_plays_skips_radar[, col_order]
#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
# Load packages
# Note quotes used in install of some packages below, becuase those otherwise would error and cannot be found and in RStudio packages list
library(shiny)
#library(ggplot2)
#devtools::install_github("ricardo-bion/ggradar")
library("ggradar")
library(scales)
#install.packages("ggiraph")
library("ggiraph")
library("moonBook")
library(sjmisc)
library(reshape2)
#install.packages("Cairo"),
#library(Cairo) # For nicer ggplot2 output when deployed on Linux
library(tidyverse)
#library(dplyr)
#loaded this explicitly in addition to tidyverse on recommendation that sometimes pipe won't work with tidyversy loaded alone, although package is included with tidyverse.
library(lubridate)
library(sf)
library(leaflet)
library(htmltools)
library(DT)
#install.packages("fmsb")
#library(fmsb) #commented out due to rewriting radarchart in ggplot2, ggiraph
library(RColorBrewer)
# Load data
# We'll use only plotted subset of the data set and columns
# so that it prints nicely
# Load data from .csv files.
track_features <- read_csv("../data/raw/track_features/tf_mini.csv")
skips <- read_csv("../data/raw/training_set/log_mini.csv")
# counts of number of times each track (by ID) appears in training dataset and sort table by counts descending
skips %>%
count(track_id_clean) %>%
arrange(desc(n))
# sample data subset; add percent not skipped
track_plays_and_skips <- skips %>%
group_by(track_id_clean) %>%
summarise(
plays = n(),
# skip_1 = sum(skip_1),
# skip_2 = sum(skip_2),
# skip_3 = sum(skip_3),
not_skipped = sum(not_skipped)
) %>%
# Take only the tracks played 50 or more times.
filter(plays >= 50) %>%
# Add percentage of times each was not skipped of its total times played.
mutate(not_skipped_pct = not_skipped / plays)
# Join features to plays_skips.
track_plays_skips_features <- track_plays_and_skips %>%
left_join(track_features, by = c("track_id_clean" = "track_id"))
# Drop least skipped dataframe to keep only desired column variables.
# Note quotes are required around objects to call columns by name in this format.
# Note: let's keep "not_skipped_pct" which in ggplot2 and ggiraph we can call column as our tooltip aesthetic for hover or on click display in Shiny.
# Note: let's keep "track_id_clean" as our required data_id aesthetic for use with ggplot2 and ggiraph interactivity and because we want this as input for Spotify Developer API engpoints later.
drop <- c("plays",
#"skip_1",
#"skip_2",
#"skip_3",
"not_skipped","dyn_range_mean","mode","acoustic_vector_0","acoustic_vector_1","acoustic_vector_2","acoustic_vector_3","acoustic_vector_4","acoustic_vector_5","acoustic_vector_6","acoustic_vector_7",
# I will also drop the features not on a 0-1 scale for this interactive ggplot ggradar chart since otherwise we would need to rescale them to 0-1 and it would appear inaccurate I think.
"us_popularity_est", "release_year", "duration", "time_signature", "tempo", "key", "loudness")
track_plays_skips_features1 = track_plays_skips_features[,!(names(track_plays_skips_features) %in% drop)]
# I just want to see the row names quick, which indeed are auto-generated sequential numbers.
#row.names(track_plays_skips_features1)
# Rename track ID as a column named group for ggradar.
track_plays_skips_features1 %>%
rename(
group = track_id_clean
)
# Add min and max to data frame as first 2 rows for range.
# Commented out because this was the requirement for radar chart with fmsb package; ggplot2 uses a single scale assigned grid.min and grid.max
# max_min <- data.frame(
#   duration = c(2000.0, 0.0), release_year = c(2021, 1950), us_popularity_estimate = c(100.0, 0.0), acousticness = c(1.0, 0.0), beat_strength = c(1.0, 0.0), bounciness =  c(1.0, 0.0), danceability = c(1.0, 0.0), energy = c(1.0, 0.0), flatness = c(1.0, 0.0), instrumentalness = c(1.0, 0.0), key = c(11, 0), liveness = c(1.0, 0.0), loudness = c(-60.0, 0.0), mechanism = c(1.0, 0.0), organism = c(1.0, 0.0), speechiness = c(1.0, 0.0), tempo = c(220.0, 0.0), time_signature = c(5, 0), valence = c(1.0, 0.0)
# )
# rownames(max_min) <- c("Max", "Min")
# # Bind the variable ranges to the data.
# tracks_plays_skips_radar <- rbind(max_min, track_plays_skips_features1)
# Adjust the columns order for a more visually effective radar chart.
col_order <- c("track_id_clean","not_skipped_pct",
# omit dropped columns due to scale besided 0-1 for now.
#"us_popularity_estimate", "release_year", "duration", "time_signature", "tempo", "key", "loudness",
"acousticness", "beat_strength", "bounciness", "danceability", "liveness", "mechanism", "organism", "energy", "flatness", "instrumentalness", "speechiness", "valence")
tracks_plays_skips_radar2 <- track_plays_skips_features1[, col_order]
# Isolate the least skipped tracks.
tracks_least_skipped_radar <- tail(tracks_plays_skips_radar2)
tracks_least_skipped_radar
#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
# Load packages
# Note quotes used in install of some packages below, becuase those otherwise would error and cannot be found and in RStudio packages list
library(shiny)
#library(ggplot2)
#devtools::install_github("ricardo-bion/ggradar")
library("ggradar")
library(scales)
#install.packages("ggiraph")
library("ggiraph")
library("moonBook")
library(sjmisc)
library(reshape2)
#install.packages("Cairo"),
#library(Cairo) # For nicer ggplot2 output when deployed on Linux
library(tidyverse)
#library(dplyr)
#loaded this explicitly in addition to tidyverse on recommendation that sometimes pipe won't work with tidyversy loaded alone, although package is included with tidyverse.
library(lubridate)
library(sf)
library(leaflet)
library(htmltools)
library(DT)
#install.packages("fmsb")
#library(fmsb) #commented out due to rewriting radarchart in ggplot2, ggiraph
library(RColorBrewer)
# Load data
# We'll use only plotted subset of the data set and columns
# so that it prints nicely
# Load data from .csv files.
track_features <- read_csv("../data/raw/track_features/tf_mini.csv")
skips <- read_csv("../data/raw/training_set/log_mini.csv")
# counts of number of times each track (by ID) appears in training dataset and sort table by counts descending
skips %>%
count(track_id_clean) %>%
arrange(desc(n))
# sample data subset; add percent not skipped
track_plays_and_skips <- skips %>%
group_by(track_id_clean) %>%
summarise(
plays = n(),
# skip_1 = sum(skip_1),
# skip_2 = sum(skip_2),
# skip_3 = sum(skip_3),
not_skipped = sum(not_skipped)
) %>%
# Take only the tracks played 50 or more times.
filter(plays >= 50) %>%
# Add percentage of times each was not skipped of its total times played.
mutate(not_skipped_pct = not_skipped / plays)
# Join features to plays_skips.
track_plays_skips_features <- track_plays_and_skips %>%
left_join(track_features, by = c("track_id_clean" = "track_id"))
# Drop least skipped dataframe to keep only desired column variables.
# Note quotes are required around objects to call columns by name in this format.
# Note: let's keep "not_skipped_pct" which in ggplot2 and ggiraph we can call column as our tooltip aesthetic for hover or on click display in Shiny.
# Note: let's keep "track_id_clean" as our required data_id aesthetic for use with ggplot2 and ggiraph interactivity and because we want this as input for Spotify Developer API engpoints later.
drop <- c("plays",
#"skip_1",
#"skip_2",
#"skip_3",
"not_skipped","dyn_range_mean","mode","acoustic_vector_0","acoustic_vector_1","acoustic_vector_2","acoustic_vector_3","acoustic_vector_4","acoustic_vector_5","acoustic_vector_6","acoustic_vector_7",
# I will also drop the features not on a 0-1 scale for this interactive ggplot ggradar chart since otherwise we would need to rescale them to 0-1 and it would appear inaccurate I think.
"us_popularity_est", "release_year", "duration", "time_signature", "tempo", "key", "loudness")
track_plays_skips_features1 = track_plays_skips_features[,!(names(track_plays_skips_features) %in% drop)]
# I just want to see the row names quick, which indeed are auto-generated sequential numbers.
#row.names(track_plays_skips_features1)
# Rename track ID as a column named group for ggradar.
track_plays_skips_features1 %>%
rename(
group = track_id_clean
)
# Add min and max to data frame as first 2 rows for range.
# Commented out because this was the requirement for radar chart with fmsb package; ggplot2 uses a single scale assigned grid.min and grid.max
# max_min <- data.frame(
#   duration = c(2000.0, 0.0), release_year = c(2021, 1950), us_popularity_estimate = c(100.0, 0.0), acousticness = c(1.0, 0.0), beat_strength = c(1.0, 0.0), bounciness =  c(1.0, 0.0), danceability = c(1.0, 0.0), energy = c(1.0, 0.0), flatness = c(1.0, 0.0), instrumentalness = c(1.0, 0.0), key = c(11, 0), liveness = c(1.0, 0.0), loudness = c(-60.0, 0.0), mechanism = c(1.0, 0.0), organism = c(1.0, 0.0), speechiness = c(1.0, 0.0), tempo = c(220.0, 0.0), time_signature = c(5, 0), valence = c(1.0, 0.0)
# )
# rownames(max_min) <- c("Max", "Min")
# # Bind the variable ranges to the data.
# tracks_plays_skips_radar <- rbind(max_min, track_plays_skips_features1)
# Adjust the columns order for a more visually effective radar chart.
col_order <- c("group","not_skipped_pct",
# omit dropped columns due to scale besided 0-1 for now.
#"us_popularity_estimate", "release_year", "duration", "time_signature", "tempo", "key", "loudness",
"acousticness", "beat_strength", "bounciness", "danceability", "liveness", "mechanism", "organism", "energy", "flatness", "instrumentalness", "speechiness", "valence")
tracks_plays_skips_radar2 <- track_plays_skips_features1[, col_order]
# Isolate the least skipped tracks.
tracks_least_skipped_radar <- tail(tracks_plays_skips_radar2)
tracks_least_skipped_radar
track_plays_skips_features1 <- track_plays_skips_features1 %>%
rename(
group = track_id_clean
)
# Add min and max to data frame as first 2 rows for range.
# Commented out because this was the requirement for radar chart with fmsb package; ggplot2 uses a single scale assigned grid.min and grid.max
# max_min <- data.frame(
#   duration = c(2000.0, 0.0), release_year = c(2021, 1950), us_popularity_estimate = c(100.0, 0.0), acousticness = c(1.0, 0.0), beat_strength = c(1.0, 0.0), bounciness =  c(1.0, 0.0), danceability = c(1.0, 0.0), energy = c(1.0, 0.0), flatness = c(1.0, 0.0), instrumentalness = c(1.0, 0.0), key = c(11, 0), liveness = c(1.0, 0.0), loudness = c(-60.0, 0.0), mechanism = c(1.0, 0.0), organism = c(1.0, 0.0), speechiness = c(1.0, 0.0), tempo = c(220.0, 0.0), time_signature = c(5, 0), valence = c(1.0, 0.0)
# )
# rownames(max_min) <- c("Max", "Min")
# # Bind the variable ranges to the data.
# tracks_plays_skips_radar <- rbind(max_min, track_plays_skips_features1)
# Adjust the columns order for a more visually effective radar chart.
col_order <- c("group","not_skipped_pct",
# omit dropped columns due to scale besided 0-1 for now.
#"us_popularity_estimate", "release_year", "duration", "time_signature", "tempo", "key", "loudness",
"acousticness", "beat_strength", "bounciness", "danceability", "liveness", "mechanism", "organism", "energy", "flatness", "instrumentalness", "speechiness", "valence")
tracks_plays_skips_radar2 <- track_plays_skips_features1[, col_order]
# Isolate the least skipped tracks.
tracks_least_skipped_radar <- tail(tracks_plays_skips_radar2)
tracks_least_skipped_radar
#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
# Load packages
# Note quotes used in install of some packages below, becuase those otherwise would error and cannot be found and in RStudio packages list
library(shiny)
#library(ggplot2)
#devtools::install_github("ricardo-bion/ggradar")
library("ggradar")
library(scales)
#install.packages("ggiraph")
library("ggiraph")
library("moonBook")
library(sjmisc)
library(reshape2)
#install.packages("Cairo"),
#library(Cairo) # For nicer ggplot2 output when deployed on Linux
library(tidyverse)
#library(dplyr)
#loaded this explicitly in addition to tidyverse on recommendation that sometimes pipe won't work with tidyversy loaded alone, although package is included with tidyverse.
library(lubridate)
library(sf)
library(leaflet)
library(htmltools)
library(DT)
#install.packages("fmsb")
#library(fmsb) #commented out due to rewriting radarchart in ggplot2, ggiraph
library(RColorBrewer)
# Load data
# We'll use only plotted subset of the data set and columns
# so that it prints nicely
# Load data from .csv files.
track_features <- read_csv("../data/raw/track_features/tf_mini.csv")
skips <- read_csv("../data/raw/training_set/log_mini.csv")
# counts of number of times each track (by ID) appears in training dataset and sort table by counts descending
skips %>%
count(track_id_clean) %>%
arrange(desc(n))
# sample data subset; add percent not skipped
track_plays_and_skips <- skips %>%
group_by(track_id_clean) %>%
summarise(
plays = n(),
# skip_1 = sum(skip_1),
# skip_2 = sum(skip_2),
# skip_3 = sum(skip_3),
not_skipped = sum(not_skipped)
) %>%
# Take only the tracks played 50 or more times.
filter(plays >= 50) %>%
# Add percentage of times each was not skipped of its total times played.
mutate(not_skipped_pct = not_skipped / plays)
# Join features to plays_skips.
track_plays_skips_features <- track_plays_and_skips %>%
left_join(track_features, by = c("track_id_clean" = "track_id"))
# Drop least skipped dataframe to keep only desired column variables.
# Note quotes are required around objects to call columns by name in this format.
# Note: let's keep "not_skipped_pct" which in ggplot2 and ggiraph we can call column as our tooltip aesthetic for hover or on click display in Shiny.
# Note: let's keep "track_id_clean" as our required data_id aesthetic for use with ggplot2 and ggiraph interactivity and because we want this as input for Spotify Developer API engpoints later.
drop <- c("plays",
#"skip_1",
#"skip_2",
#"skip_3",
"not_skipped","dyn_range_mean","mode","acoustic_vector_0","acoustic_vector_1","acoustic_vector_2","acoustic_vector_3","acoustic_vector_4","acoustic_vector_5","acoustic_vector_6","acoustic_vector_7",
# I will also drop the features not on a 0-1 scale for this interactive ggplot ggradar chart since otherwise we would need to rescale them to 0-1 and it would appear inaccurate I think.
"us_popularity_est", "release_year", "duration", "time_signature", "tempo", "key", "loudness")
track_plays_skips_features1 = track_plays_skips_features[,!(names(track_plays_skips_features) %in% drop)]
# I just want to see the row names quick, which indeed are auto-generated sequential numbers.
#row.names(track_plays_skips_features1)
# Rename track ID as a column named group for ggradar.
track_plays_skips_features1 <- track_plays_skips_features1 %>%
rename(
group = track_id_clean
)
# Add min and max to data frame as first 2 rows for range.
# Commented out because this was the requirement for radar chart with fmsb package; ggplot2 uses a single scale assigned grid.min and grid.max
# max_min <- data.frame(
#   duration = c(2000.0, 0.0), release_year = c(2021, 1950), us_popularity_estimate = c(100.0, 0.0), acousticness = c(1.0, 0.0), beat_strength = c(1.0, 0.0), bounciness =  c(1.0, 0.0), danceability = c(1.0, 0.0), energy = c(1.0, 0.0), flatness = c(1.0, 0.0), instrumentalness = c(1.0, 0.0), key = c(11, 0), liveness = c(1.0, 0.0), loudness = c(-60.0, 0.0), mechanism = c(1.0, 0.0), organism = c(1.0, 0.0), speechiness = c(1.0, 0.0), tempo = c(220.0, 0.0), time_signature = c(5, 0), valence = c(1.0, 0.0)
# )
# rownames(max_min) <- c("Max", "Min")
# # Bind the variable ranges to the data.
# tracks_plays_skips_radar <- rbind(max_min, track_plays_skips_features1)
# Adjust the columns order for a more visually effective radar chart.
col_order <- c("group","not_skipped_pct",
# omit dropped columns due to scale besided 0-1 for now.
#"us_popularity_estimate", "release_year", "duration", "time_signature", "tempo", "key", "loudness",
"acousticness", "beat_strength", "bounciness", "danceability", "liveness", "mechanism", "organism", "energy", "flatness", "instrumentalness", "speechiness", "valence")
tracks_plays_skips_radar2 <- track_plays_skips_features1[, col_order]
# Isolate the least skipped tracks.
tracks_least_skipped_radar <- tail(tracks_plays_skips_radar2)
tracks_least_skipped_radar
# Isolate most skipped tracks.
# Most skipped commented out with fmsb package radarchart in debugging to troubleshoot Warning: Error in writeImpl: Text to be written must be a length-one character vector [No stack trace available]
#tracks_most_skipped_radar <- head(tracks_plays_skips_radar2)
#tracks_most_skipped_features
# Define UI for application
ui <- fluidPage(titlePanel("Sell Out Music Listener"),
fluidRow(
column(width = 4,
plotOutput("plot1", height = 300,
# Equivalent to: click = clickOpts(id = "plot_click")
click = "plot1_click",
brush = brushOpts(
id = "plot1_brush"
)
)
)
),
fluidRow(
column(width = 6,
h4("Points near click"),
verbatimTextOutput("click_info")
),
column(width = 6,
h4("Brushed points"),
verbatimTextOutput("brush_info")
)
)
)
server <- function(input, output) {
output$plot1 <- renderPlot({
# First we will get the least skipped working in ggradar, and then we may return to plot the comparison most skipped beside it
# Now we will plot the least and most skipped charts beside one another for comparison.
#opar <- par()
# Define settings for plotting in a 1x2 (2 column) grid, with appropriate margins:
#par(mar = rep(.8,4)) #may require testing to get margins between plots looking good
#par(mfrow = c(1,2)) # 1 row, 2 columns
# Produce a radar-chart for each desired plot again, least skipped at left; most to right
# Customized least skipped radar chart
ggradar(
tracks_least_skipped_radar,
# Add a plot title.
plot.title = "Features of Least Skipped Spotify Tracks",
# Custom labels (removed for now any audio feature columns not on 0-1 scale: "US Popularity est. %", "Release Year", "Duration (ms)", "Time Signature", "Tempo", "Key", "Loudness", )
axis.labels = c("Acousticness", "Beat Strength", "Bounciness", "Danceability", "Liveness", "Mechanism", "Organism", "Energy", "Flatness", "Instrumentalness", "Speechiness", "Valence"),
axis.label.size = 0.8,
# We could offset the axis labels further away from the max circle if they appear crowded, measured relative to circle diameter.
#axis.label.offset = 2 # We'll test the default 1.15 first.
# Note ggradar does not appear to have an axis color option, as we used "grey30" in fmsb (i.e. axislabcol = "grey30").
values.radar = c("0", "0.5", "1"),
# Grid line values (3 lines drawn)
grid.min = 0, grid.mid = 0.5, grid.max = 1,
# Polygons
group.line.width = 0.8,
group.point.size = 3,
# Colors the lines of the polygon(s), let's generalize all of these 'good' i.e. least skipped as a similar range of color using a R palette, since we'll compare it to 'bad' most skipped, not among themselves as much.
group.colours = palette_greens,
# Adds same colors as fill to polygons with more transparency (not clear yet how to convert this from fmsb to ggradar).
#pfcol = palette_greens_in,
# Background and grid lines (types and colors)
background.circle.colour = "white", # Note, default is yellow in ggradar.
grid.line.width = 0.8,
gridline.min.linetype = "solid",
gridline.mid.linetype = "solid",
gridline.max.linetype = "solid", # Note, default is long dashed line in ggradar.
# Note the min and max lines' color defaults are grey so we don't have to state them.
gridline.mid.colour = "grey", # Default for the mid point line is blue, which I would find distracting in this case.
# No legend desired.
plot.legend = FALSE,
# Legend position (probably don't want a legend showing Track ID; we're concerned with these as a visual group of least skipped with some variation.)
#legend.position = "bottom",
# How do we make this interactive now...
# interactive = TRUE
)
runApp('Sell-Out-Music')
shiny::runApp('Sell-Out-Music')
