energy,
bounciness,
beat_strength,
danceability,
flatness,
instrumentalness
) %>%
gather(key = metric_name, value = metric, -not_skipped_pct) %>%
ggplot(aes(x = metric, y = not_skipped_pct)) +
geom_point() +
facet_wrap(~metric_name) +
# Add an understandable plot title and clean axis labels
ggtitle("Percentage of Times each Track was Skipped of its Times Played \n by Various Audio Metrics") +
xlab("metric") + ylab("Not Skipped %") +
theme(plot.title = element_text(hjust = 0.5))
# The fmsb library is useful to build a basic radar chart
# Very specific input format is required so first we need to revisit and reshape our data track_plays_skips_features
# According to https://www.r-graph-gallery.com/142-basic-radar-chart.html: "Each row must be an entity. Each column is a quantitative variable.
# First 2 rows provide the min and the max that will be used for each variable."
# Our project goal is to show our musician client how to "sell out" i.e. what kind of music to make to achieve the most plays with least skips, so we'll start with the tail of the dataset we've isolated,
# since it already is sorted descending by skips, this will give us the last 10 rows which all were played more than 50 times but were skipped the least of the songs played that many times or more.
tracks_least_skipped_features <- tail(track_plays_skips_features)
tracks_least_skipped_features
# Let's check data types.
glimpse(tracks_least_skipped_features)
# Subset remove column (-c); do not use quotes around column names in subset.
# Commented out due to error I could not yet debug; trying a different method instead "Error in -c(not_skipped_pct, track_id_clean, plays, skip_1, skip_2, skip_3, not_skipped, : invalid argument to unary operator"
#tracks_least_skipped_radar = subset(tracks_least_skipped_features, -c(not_skipped_pct,track_id_clean,plays,skip_1,skip_2,skip_3,not_skipped,dyn_range_mean,mode,acoustic_vector_0,acoustic_vector_1,acoustic_vector_2,acoustic_vector_3,acoustic_vector_4,acoustic_vector_5,acoustic_vector_6,acoustic_vector_7))
# Note quotes are required around objects to call columns by name in this format.
drop <- c("not_skipped_pct","track_id_clean","plays","skip_1","skip_2","skip_3","not_skipped","dyn_range_mean","mode","acoustic_vector_0","acoustic_vector_1","acoustic_vector_2","acoustic_vector_3","acoustic_vector_4","acoustic_vector_5","acoustic_vector_6","acoustic_vector_7")
tracks_least_skipped_radar = tracks_least_skipped_features[,!(names(tracks_least_skipped_features) %in% drop)]
glimpse(tracks_least_skipped_radar)
apply(track_features,2,min)
apply(track_features,2,max)
# Add 2 lines to least skipped radar dataframe: min and max of each column to show on plot.
# First because we have different ranges, we'll need to specify each in a dataframe of their own.
# Determined from aproximate min/max in training set: duration, release_year, us_popularity_estimate, key, loudness (backed up by research), mechanism, organism (those 2 were not listed in Spotify docs I found at all), energy flatness, time_signature
# Note acoustiness, energy max, instrumentalness in dataset were 9.9... but docs indicate each is a 0.0 to 1.0 scale aligned with other columns; I'll test both for chart effectiveness (likely a data anomoly/error(s) exist outside above 1.0).
# Switched the erroneous 0 to 10 ranges to the 0 to 1 listed in docs because test proved that none in our dataset appeared away from the center of radar chart at 0. Except instrumentalness which does have many values above 1 in our dataset.
# Dynamic range also is accounted for as part of energy calculation so if its range is ineffective visually with the others, we could omit that column as its own variable as somewhat redundant.
# Updated to remove: dyn_range_mean = c(35.0, 0.0).
# Loudness in max aggregation shows -60 as the max, but as a natural scale I flipped min to that negative end of range whereas 0 became the max (and 0 was min in R aggregate function calculation).
# However, after testing, I switched loudness back to max as -60 because this allowed the center of radar range point to be 0 for all except the year, which makes for a more congruent view across variables with different range end points.
max_min <- data.frame(
duration = c(2000.0, 0.0), release_year = c(2021, 1950), us_popularity_estimate = c(100.0, 0.0), acousticness = c(1.0, 0.0), beat_strength = c(1.0, 0.0), bounciness =  c(1.0, 0.0), danceability = c(1.0, 0.0), energy = c(1.0, 0.0), flatness = c(1.0, 0.0), instrumentalness = c(10.0, 0.0), key = c(11, 0), liveness = c(1.0, 0.0), loudness = c(-60.0, 0.0), mechanism = c(1.0, 0.0), organism = c(1.0, 0.0), speechiness = c(1.0, 0.0), tempo = c(220.0, 0.0), time_signature = c(5, 0), valence = c(1.0, 0.0)
)
rownames(max_min) <- c("Max", "Min")
# Bind the variable ranges to the data.
tracks_least_skipped_radar <- rbind(max_min, tracks_least_skipped_radar)
# Display the dataframe result.
tracks_least_skipped_radar
radarchart(tracks_least_skipped_radar)
# Add rownames back on for interactivity or if we split this into separate radar charts for each later.
# This error seems to be because the percents are floats not integers: Error in `.rowNamesDF<-`(x, value = value) : invalid 'row.names' length
#rownames(tracks_least_skipped_radar) <- paste(tracks_least_skipped_features[,"not_skipped_pct"], "% Skipped")
# Note fmsb package plots radar in counter clockwise order, so we'll order our vector of column names according to what should appear last (12 o'clock) to 9:00 to 6:00 to 3:00, etc.
# Updated to remove "dyn_range_mean".
col_order <- c("us_popularity_estimate", "release_year", "duration", "acousticness", "beat_strength", "bounciness", "danceability", "energy", "flatness", "instrumentalness", "liveness", "mechanism", "organism", "speechiness", "loudness", "key", "tempo", "time_signature", "valence")
tracks_least_skipped_radar2 <- tracks_least_skipped_radar[, col_order]
# Rounding this to specific number of decimal places similar to others because the 'e-' exponential format does not plot (they all show up at 0).
tracks_least_skipped_radar2$instrumentalness <- round(tracks_least_skipped_radar2$instrumentalness, digit=7)
# Show the datatable
tracks_least_skipped_radar2
# set a color palette variable for some greens that will be understood as a relative group (of the least skipped), and remain somewhat visible as distinct tracks individually also.
palette_greens <- brewer.pal(8,"Greens")
# for the fill of polygons, let's add some transparency with alpha
palette_greens_in <- alpha(palette_greens,0.2)
# Customize the radar chart
radarchart(tracks_least_skipped_radar2, axistype = 2,
#add a title
title = "Features of Least Skipped Spotify Tracks",
#custom polygon, let's generalize all of these 'good' i.e. least skipped as a similar range of color using a R palette, since we'll compare it to 'bad' most skipped, not among themselves as much
pcol = palette_greens, #colors the lines
pfcol = palette_greens_in, #adds same colors as fill to polygons
#custom the grid
cglcol = "grey", cglty = 1, axislabcol = "grey30", cglwd = 0.8,
#custom labels
vlcex = 0.8
)
sessionInfo()
View(tracks_least_skipped_radar)
# Disable scientific notation in double numbers, because instrumentalness otherwise did not test plotting accurately (plotted at zero)
options(scipen = 999)
knitr::opts_chunk$set(
echo = F,
warning = F,
message = F,
include = T,
cache = F,
fig.width = 6,
fig.height = 4,
out.width = "100%",
out.height = "100%"
)
knitr::clean_cache(
clean = FALSE,
path = knitr::opts_chunk$get("cache.path")
)
# package object 'ggiteam' is a color standard styling pckg for City of Balt. (see https://rdrr.io/github/city-of-baltimore/ggiteam/src/R/ggiteam.R)
#install.packages("remotes")
#remotes::install_github("city-of-baltimore/ggiteam")
library(tidyverse)
library(lubridate)
library(sf)
library(leaflet)
#library(ggiteam)
#library(package)
#library(kableExtra)
library(htmltools)
library(DT)
# Note quotes used in install of package below, becuase it otherwise would error and cannot be found and in RStudio packages list
#install.packages("fmsb")
library(fmsb)
library(viridis)
library(RColorBrewer)
library(ggplot2)
track_features <- read_csv("../data/raw/track_features/tf_mini.csv")
skips <- read_csv("../data/raw/training_set/log_mini.csv")
# counts
skips %>%
count(track_id_clean) %>%
arrange(desc(n))
track_plays_and_skips <- skips %>%
group_by(track_id_clean) %>%
summarise(
plays = n(),
skip_1 = sum(skip_1),
skip_2 = sum(skip_2),
skip_3 = sum(skip_3),
not_skipped = sum(not_skipped)
) %>%
filter(plays >= 50) %>%
mutate(not_skipped_pct = not_skipped / plays)
track_plays_skips_features <- track_plays_and_skips %>%
left_join(track_features, by = c("track_id_clean" = "track_id"))
glimpse(track_plays_skips_features)
p <- track_plays_skips_features %>%
ggplot(aes(x = energy, y = not_skipped_pct)) +
geom_point()
# Add an understandable plot title and clean axis labels
p + ggtitle("Percentage of Times each Track was Skipped of its Times Played \n by Energy of Tracks") +
xlab("Energy") + ylab("Not Skipped %") +
theme(plot.title = element_text(hjust = 0.5))
track_plays_skips_features %>%
select(
not_skipped_pct,
energy,
bounciness,
beat_strength,
danceability,
flatness,
instrumentalness
) %>%
gather(key = metric_name, value = metric, -not_skipped_pct) %>%
ggplot(aes(x = metric, y = not_skipped_pct)) +
geom_point() +
facet_wrap(~metric_name) +
# Add an understandable plot title and clean axis labels
ggtitle("Percentage of Times each Track was Skipped of its Times Played \n by Various Audio Metrics") +
xlab("metric") + ylab("Not Skipped %") +
theme(plot.title = element_text(hjust = 0.5))
# The fmsb library is useful to build a basic radar chart
# Very specific input format is required so first we need to revisit and reshape our data track_plays_skips_features
# According to https://www.r-graph-gallery.com/142-basic-radar-chart.html: "Each row must be an entity. Each column is a quantitative variable.
# First 2 rows provide the min and the max that will be used for each variable."
# Our project goal is to show our musician client how to "sell out" i.e. what kind of music to make to achieve the most plays with least skips, so we'll start with the tail of the dataset we've isolated,
# since it already is sorted descending by skips, this will give us the last 10 rows which all were played more than 50 times but were skipped the least of the songs played that many times or more.
tracks_least_skipped_features <- tail(track_plays_skips_features)
tracks_least_skipped_features
# Let's check data types.
glimpse(tracks_least_skipped_features)
# Subset remove column (-c); do not use quotes around column names in subset.
# Commented out due to error I could not yet debug; trying a different method instead "Error in -c(not_skipped_pct, track_id_clean, plays, skip_1, skip_2, skip_3, not_skipped, : invalid argument to unary operator"
#tracks_least_skipped_radar = subset(tracks_least_skipped_features, -c(not_skipped_pct,track_id_clean,plays,skip_1,skip_2,skip_3,not_skipped,dyn_range_mean,mode,acoustic_vector_0,acoustic_vector_1,acoustic_vector_2,acoustic_vector_3,acoustic_vector_4,acoustic_vector_5,acoustic_vector_6,acoustic_vector_7))
# Note quotes are required around objects to call columns by name in this format.
drop <- c("not_skipped_pct","track_id_clean","plays","skip_1","skip_2","skip_3","not_skipped","dyn_range_mean","mode","acoustic_vector_0","acoustic_vector_1","acoustic_vector_2","acoustic_vector_3","acoustic_vector_4","acoustic_vector_5","acoustic_vector_6","acoustic_vector_7")
tracks_least_skipped_radar = tracks_least_skipped_features[,!(names(tracks_least_skipped_features) %in% drop)]
glimpse(tracks_least_skipped_radar)
apply(track_features,2,min)
apply(track_features,2,max)
# Add 2 lines to least skipped radar dataframe: min and max of each column to show on plot.
# First because we have different ranges, we'll need to specify each in a dataframe of their own.
# Determined from aproximate min/max in training set: duration, release_year, us_popularity_estimate, key, loudness (backed up by research), mechanism, organism (those 2 were not listed in Spotify docs I found at all), energy flatness, time_signature
# Note acoustiness, energy max, instrumentalness in dataset were 9.9... but docs indicate each is a 0.0 to 1.0 scale aligned with other columns; I'll test both for chart effectiveness (likely a data anomoly/error(s) exist outside above 1.0).
# Switched the erroneous 0 to 10 ranges to the 0 to 1 listed in docs because test proved that none in our dataset appeared away from the center of radar chart at 0. Except instrumentalness which does have many values above 1 in our dataset.
# Dynamic range also is accounted for as part of energy calculation so if its range is ineffective visually with the others, we could omit that column as its own variable as somewhat redundant.
# Updated to remove: dyn_range_mean = c(35.0, 0.0).
# Loudness in max aggregation shows -60 as the max, but as a natural scale I flipped min to that negative end of range whereas 0 became the max (and 0 was min in R aggregate function calculation).
# However, after testing, I switched loudness back to max as -60 because this allowed the center of radar range point to be 0 for all except the year, which makes for a more congruent view across variables with different range end points.
max_min <- data.frame(
duration = c(2000.0, 0.0), release_year = c(2021, 1950), us_popularity_estimate = c(100.0, 0.0), acousticness = c(1.0, 0.0), beat_strength = c(1.0, 0.0), bounciness =  c(1.0, 0.0), danceability = c(1.0, 0.0), energy = c(1.0, 0.0), flatness = c(1.0, 0.0), instrumentalness = c(10.0, 0.0), key = c(11, 0), liveness = c(1.0, 0.0), loudness = c(-60.0, 0.0), mechanism = c(1.0, 0.0), organism = c(1.0, 0.0), speechiness = c(1.0, 0.0), tempo = c(220.0, 0.0), time_signature = c(5, 0), valence = c(1.0, 0.0)
)
rownames(max_min) <- c("Max", "Min")
# Bind the variable ranges to the data.
tracks_least_skipped_radar <- rbind(max_min, tracks_least_skipped_radar)
# Display the dataframe result.
tracks_least_skipped_radar
radarchart(tracks_least_skipped_radar)
# Add rownames back on for interactivity or if we split this into separate radar charts for each later.
# This error seems to be because the percents are floats not integers: Error in `.rowNamesDF<-`(x, value = value) : invalid 'row.names' length
#rownames(tracks_least_skipped_radar) <- paste(tracks_least_skipped_features[,"not_skipped_pct"], "% Skipped")
# Note fmsb package plots radar in counter clockwise order, so we'll order our vector of column names according to what should appear last (12 o'clock) to 9:00 to 6:00 to 3:00, etc.
# Updated to remove "dyn_range_mean".
col_order <- c("us_popularity_estimate", "release_year", "duration", "acousticness", "beat_strength", "bounciness", "danceability", "energy", "flatness", "instrumentalness", "liveness", "mechanism", "organism", "speechiness", "loudness", "key", "tempo", "time_signature", "valence")
tracks_least_skipped_radar2 <- tracks_least_skipped_radar[, col_order]
# Show the datatable
tracks_least_skipped_radar2
# set a color palette variable for some greens that will be understood as a relative group (of the least skipped), and remain somewhat visible as distinct tracks individually also.
palette_greens <- brewer.pal(8,"Greens")
# for the fill of polygons, let's add some transparency with alpha
palette_greens_in <- alpha(palette_greens,0.2)
# Customize the radar chart
radarchart(tracks_least_skipped_radar2, axistype = 2,
#add a title
title = "Features of Least Skipped Spotify Tracks",
#custom polygon, let's generalize all of these 'good' i.e. least skipped as a similar range of color using a R palette, since we'll compare it to 'bad' most skipped, not among themselves as much
pcol = palette_greens, #colors the lines
pfcol = palette_greens_in, #adds same colors as fill to polygons
#custom the grid
cglcol = "grey", cglty = 1, axislabcol = "grey30", cglwd = 0.8,
#custom labels
vlcex = 0.8
)
sessionInfo()
# Disable scientific notation in double numbers, because instrumentalness otherwise did not test plotting accurately (plotted at zero)
options(scipen = 999)
knitr::opts_chunk$set(
echo = F,
warning = F,
message = F,
include = T,
cache = F,
fig.width = 6,
fig.height = 4,
out.width = "100%",
out.height = "100%"
)
knitr::clean_cache(
clean = FALSE,
path = knitr::opts_chunk$get("cache.path")
)
# package object 'ggiteam' is a color standard styling pckg for City of Balt. (see https://rdrr.io/github/city-of-baltimore/ggiteam/src/R/ggiteam.R)
#install.packages("remotes")
#remotes::install_github("city-of-baltimore/ggiteam")
library(tidyverse)
library(lubridate)
library(sf)
library(leaflet)
#library(ggiteam)
#library(package)
#library(kableExtra)
library(htmltools)
library(DT)
# Note quotes used in install of package below, becuase it otherwise would error and cannot be found and in RStudio packages list
#install.packages("fmsb")
library(fmsb)
library(viridis)
library(RColorBrewer)
library(ggplot2)
track_features <- read_csv("../data/raw/track_features/tf_mini.csv")
skips <- read_csv("../data/raw/training_set/log_mini.csv")
# counts
skips %>%
count(track_id_clean) %>%
arrange(desc(n))
track_plays_and_skips <- skips %>%
group_by(track_id_clean) %>%
summarise(
plays = n(),
skip_1 = sum(skip_1),
skip_2 = sum(skip_2),
skip_3 = sum(skip_3),
not_skipped = sum(not_skipped)
) %>%
filter(plays >= 50) %>%
mutate(not_skipped_pct = not_skipped / plays)
track_plays_skips_features <- track_plays_and_skips %>%
left_join(track_features, by = c("track_id_clean" = "track_id"))
glimpse(track_plays_skips_features)
p <- track_plays_skips_features %>%
ggplot(aes(x = energy, y = not_skipped_pct)) +
geom_point()
# Add an understandable plot title and clean axis labels
p + ggtitle("Percentage of Times each Track was Skipped of its Times Played \n by Energy of Tracks") +
xlab("Energy") + ylab("Not Skipped %") +
theme(plot.title = element_text(hjust = 0.5))
track_plays_skips_features %>%
select(
not_skipped_pct,
energy,
bounciness,
beat_strength,
danceability,
flatness,
instrumentalness
) %>%
gather(key = metric_name, value = metric, -not_skipped_pct) %>%
ggplot(aes(x = metric, y = not_skipped_pct)) +
geom_point() +
facet_wrap(~metric_name) +
# Add an understandable plot title and clean axis labels
ggtitle("Percentage of Times each Track was Skipped of its Times Played \n by Various Audio Metrics") +
xlab("metric") + ylab("Not Skipped %") +
theme(plot.title = element_text(hjust = 0.5))
# The fmsb library is useful to build a basic radar chart
# Very specific input format is required so first we need to revisit and reshape our data track_plays_skips_features
# According to https://www.r-graph-gallery.com/142-basic-radar-chart.html: "Each row must be an entity. Each column is a quantitative variable.
# First 2 rows provide the min and the max that will be used for each variable."
# Our project goal is to show our musician client how to "sell out" i.e. what kind of music to make to achieve the most plays with least skips, so we'll start with the tail of the dataset we've isolated,
# since it already is sorted descending by skips, this will give us the last 10 rows which all were played more than 50 times but were skipped the least of the songs played that many times or more.
tracks_least_skipped_features <- tail(track_plays_skips_features)
tracks_least_skipped_features
# Let's check data types.
glimpse(tracks_least_skipped_features)
# Subset remove column (-c); do not use quotes around column names in subset.
# Commented out due to error I could not yet debug; trying a different method instead "Error in -c(not_skipped_pct, track_id_clean, plays, skip_1, skip_2, skip_3, not_skipped, : invalid argument to unary operator"
#tracks_least_skipped_radar = subset(tracks_least_skipped_features, -c(not_skipped_pct,track_id_clean,plays,skip_1,skip_2,skip_3,not_skipped,dyn_range_mean,mode,acoustic_vector_0,acoustic_vector_1,acoustic_vector_2,acoustic_vector_3,acoustic_vector_4,acoustic_vector_5,acoustic_vector_6,acoustic_vector_7))
# Note quotes are required around objects to call columns by name in this format.
drop <- c("not_skipped_pct","track_id_clean","plays","skip_1","skip_2","skip_3","not_skipped","dyn_range_mean","mode","acoustic_vector_0","acoustic_vector_1","acoustic_vector_2","acoustic_vector_3","acoustic_vector_4","acoustic_vector_5","acoustic_vector_6","acoustic_vector_7")
tracks_least_skipped_radar = tracks_least_skipped_features[,!(names(tracks_least_skipped_features) %in% drop)]
glimpse(tracks_least_skipped_radar)
apply(track_features,2,min)
apply(track_features,2,max)
# Add 2 lines to least skipped radar dataframe: min and max of each column to show on plot.
# First because we have different ranges, we'll need to specify each in a dataframe of their own.
# Determined from aproximate min/max in training set: duration, release_year, us_popularity_estimate, key, loudness (backed up by research), mechanism, organism (those 2 were not listed in Spotify docs I found at all), energy flatness, time_signature
# Note acoustiness, energy max, instrumentalness in dataset were 9.9... but docs indicate each is a 0.0 to 1.0 scale aligned with other columns; I'll test both for chart effectiveness (likely a data anomoly/error(s) exist outside above 1.0).
# Switched the erroneous 0 to 10 ranges to the 0 to 1 listed in docs because test proved that none in our dataset appeared away from the center of radar chart at 0. Once I disabled scientific notation, instrumentalness dropped values down below 1.0 in our dataset.
# Dynamic range also is accounted for as part of energy calculation so if its range is ineffective visually with the others, we could omit that column as its own variable as somewhat redundant.
# Updated to remove: dyn_range_mean = c(35.0, 0.0).
# Loudness in max aggregation shows -60 as the max, but as a natural scale I flipped min to that negative end of range whereas 0 became the max (and 0 was min in R aggregate function calculation).
# However, after testing, I switched loudness back to max as -60 because this allowed the center of radar range point to be 0 for all except the year, which makes for a more congruent view across variables with different range end points.
max_min <- data.frame(
duration = c(2000.0, 0.0), release_year = c(2021, 1950), us_popularity_estimate = c(100.0, 0.0), acousticness = c(1.0, 0.0), beat_strength = c(1.0, 0.0), bounciness =  c(1.0, 0.0), danceability = c(1.0, 0.0), energy = c(1.0, 0.0), flatness = c(1.0, 0.0), instrumentalness = c(1.0, 0.0), key = c(11, 0), liveness = c(1.0, 0.0), loudness = c(-60.0, 0.0), mechanism = c(1.0, 0.0), organism = c(1.0, 0.0), speechiness = c(1.0, 0.0), tempo = c(220.0, 0.0), time_signature = c(5, 0), valence = c(1.0, 0.0)
)
rownames(max_min) <- c("Max", "Min")
# Bind the variable ranges to the data.
tracks_least_skipped_radar <- rbind(max_min, tracks_least_skipped_radar)
# Display the dataframe result.
tracks_least_skipped_radar
radarchart(tracks_least_skipped_radar)
# Add rownames back on for interactivity or if we split this into separate radar charts for each later.
# This error seems to be because the percents are floats not integers: Error in `.rowNamesDF<-`(x, value = value) : invalid 'row.names' length
#rownames(tracks_least_skipped_radar) <- paste(tracks_least_skipped_features[,"not_skipped_pct"], "% Skipped")
# Note fmsb package plots radar in counter clockwise order, so we'll order our vector of column names according to what should appear last (12 o'clock) to 9:00 to 6:00 to 3:00, etc.
# Updated to remove "dyn_range_mean".
col_order <- c("us_popularity_estimate", "release_year", "duration", "acousticness", "beat_strength", "bounciness", "danceability", "energy", "flatness", "instrumentalness", "liveness", "mechanism", "organism", "speechiness", "loudness", "key", "tempo", "time_signature", "valence")
tracks_least_skipped_radar2 <- tracks_least_skipped_radar[, col_order]
# Show the datatable
tracks_least_skipped_radar2
# set a color palette variable for some greens that will be understood as a relative group (of the least skipped), and remain somewhat visible as distinct tracks individually also.
palette_greens <- brewer.pal(8,"Greens")
# for the fill of polygons, let's add some transparency with alpha
palette_greens_in <- alpha(palette_greens,0.2)
# Customize the radar chart
radarchart(tracks_least_skipped_radar2, axistype = 2,
#add a title
title = "Features of Least Skipped Spotify Tracks",
#custom polygon, let's generalize all of these 'good' i.e. least skipped as a similar range of color using a R palette, since we'll compare it to 'bad' most skipped, not among themselves as much
pcol = palette_greens, #colors the lines
pfcol = palette_greens_in, #adds same colors as fill to polygons
#custom the grid
cglcol = "grey", cglty = 1, axislabcol = "grey30", cglwd = 0.8,
#custom labels
vlcex = 0.8
)
sessionInfo()
# Note fmsb package plots radar in counter clockwise order, so we'll order our vector of column names according to what should appear last (12 o'clock) to 9:00 to 6:00 to 3:00, etc.
# Updated to remove "dyn_range_mean".
col_order <- c("us_popularity_estimate", "release_year", "duration", "tempo", "time_signature", "key", "loudness", "acousticness", "beat_strength", "bounciness", "danceability", "energy", "flatness", "instrumentalness", "liveness", "mechanism", "organism", "speechiness", "valence")
# Note fmsb package plots radar in counter clockwise order, so we'll order our vector of column names according to what should appear last (12 o'clock) to 9:00 to 6:00 to 3:00, etc.
# Updated to remove "dyn_range_mean".
col_order <- c("us_popularity_estimate", "release_year", "duration", "tempo", "time_signature", "key", "loudness", "acousticness", "beat_strength", "bounciness", "danceability", "energy", "flatness", "instrumentalness", "liveness", "mechanism", "organism", "speechiness", "valence")
tracks_least_skipped_radar2 <- tracks_least_skipped_radar[, col_order]
# Show the datatable
tracks_least_skipped_radar2
# set a color palette variable for some greens that will be understood as a relative group (of the least skipped), and remain somewhat visible as distinct tracks individually also.
palette_greens <- brewer.pal(8,"Greens")
# for the fill of polygons, let's add some transparency with alpha
palette_greens_in <- alpha(palette_greens,0.2)
# Customize the radar chart
radarchart(tracks_least_skipped_radar2, axistype = 2,
#add a title
title = "Features of Least Skipped Spotify Tracks",
#custom polygon, let's generalize all of these 'good' i.e. least skipped as a similar range of color using a R palette, since we'll compare it to 'bad' most skipped, not among themselves as much
pcol = palette_greens, #colors the lines
pfcol = palette_greens_in, #adds same colors as fill to polygons
#custom the grid
cglcol = "grey", cglty = 1, axislabcol = "grey30", cglwd = 0.8,
#custom labels
vlcex = 0.8
)
sessionInfo()
```{r plot tracks_least_skipped_radar customized radar chart}
# set a color palette variable for some greens that will be understood as a relative group (of the least skipped), and remain somewhat visible as distinct tracks individually also.
palette_greens <- brewer.pal(8,"Greens")
# for the fill of polygons, let's add some transparency with alpha
palette_greens_in <- alpha(palette_greens,0.2)
# Customize the radar chart
radarchart(tracks_least_skipped_radar2, axistype = 2,
#add a title
title = "Features of Least Skipped Spotify Tracks",
#custom polygon, let's generalize all of these 'good' i.e. least skipped as a similar range of color using a R palette, since we'll compare it to 'bad' most skipped, not among themselves as much
pcol = palette_greens, #colors the lines
pfcol = palette_greens_in, #adds same colors as fill to polygons
#custom the grid
cglcol = "grey", cglty = 1, axislabcol = "grey30", cglwd = 0.8,
#custom labels
vlabels=c("US Popularity est. %", "Release Year", "Duration (ms)", "Tempo", "Time Signature", "Key", "Loudness", "Acousticness", "Beat Strength", "Bounciness", "Danceability", "Energy", "Flatness", "Instrumentalness", "Liveness", "Mechanism", "Organism", "Speechiness", "Valence"),
vlcex = 0.75,
#plot just a zero in center because all scales share min as 0
caxislabels=c("0", "", "", "", "")
)
```
# Customize the radar chart
radarchart(tracks_least_skipped_radar2, axistype = 2,
#add a title
title = "Features of Least Skipped Spotify Tracks",
#custom polygon, let's generalize all of these 'good' i.e. least skipped as a similar range of color using a R palette, since we'll compare it to 'bad' most skipped, not among themselves as much
pcol = palette_greens, #colors the lines
pfcol = palette_greens_in, #adds same colors as fill to polygons
#custom the grid
cglcol = "grey", cglty = 2, axislabcol = "grey30", cglwd = 0.8,
#custom labels
vlabels=c("US Popularity est. %", "Release Year", "Duration (ms)", "Tempo", "Time Signature", "Key", "Loudness", "Acousticness", "Beat Strength", "Bounciness", "Danceability", "Energy", "Flatness", "Instrumentalness", "Liveness", "Mechanism", "Organism", "Speechiness", "Valence"),
vlcex = 0.75,
#plot just a zero in center because all scales share min as 0
caxislabels=c("0", "", "", "", "")
)
# set a color palette variable for some greens that will be understood as a relative group (of the least skipped), and remain somewhat visible as distinct tracks individually also.
palette_greens <- brewer.pal(8,"Greens")
# for the fill of polygons, let's add some transparency with alpha
palette_greens_in <- alpha(palette_greens,0.2)
# Customize the radar chart
radarchart(tracks_least_skipped_radar2, axistype = 3,
#add a title
title = "Features of Least Skipped Spotify Tracks",
#custom polygon, let's generalize all of these 'good' i.e. least skipped as a similar range of color using a R palette, since we'll compare it to 'bad' most skipped, not among themselves as much
pcol = palette_greens, #colors the lines
pfcol = palette_greens_in, #adds same colors as fill to polygons
#custom the grid
cglcol = "grey", cglty = 1, axislabcol = "grey30", cglwd = 0.8,
#custom labels
vlabels=c("US Popularity est. %", "Release Year", "Duration (ms)", "Tempo", "Time Signature", "Key", "Loudness", "Acousticness", "Beat Strength", "Bounciness", "Danceability", "Energy", "Flatness", "Instrumentalness", "Liveness", "Mechanism", "Organism", "Speechiness", "Valence"),
vlcex = 0.75,
#plot just a zero in center because all scales share min as 0
caxislabels=c("0", "", "", "", "")
)
track_plays_skips_features %>%
select(
not_skipped_pct,
energy,
bounciness,
beat_strength,
danceability,
flatness,
instrumentalness,
speechiness,
acousticness,
liveness
) %>%
gather(key = metric_name, value = metric, -not_skipped_pct) %>%
ggplot(aes(x = metric, y = not_skipped_pct)) +
geom_point() +
facet_wrap(~metric_name) +
# Add an understandable plot title and clean axis labels
ggtitle("Percentage of Times each Track was Skipped of its Times Played \n by Various Audio Metrics") +
xlab("metric") + ylab("Not Skipped %") +
theme(plot.title = element_text(hjust = 0.5))
track_plays_skips_features %>%
select(
not_skipped_pct,
energy,
bounciness,
beat_strength,
danceability,
flatness,
instrumentalness,
speechiness,
acousticness,
liveness,
loudness
) %>%
gather(key = metric_name, value = metric, -not_skipped_pct) %>%
ggplot(aes(x = metric, y = not_skipped_pct)) +
geom_point() +
facet_wrap(~metric_name) +
# Add an understandable plot title and clean axis labels
ggtitle("Percentage of Times each Track was Skipped of its Times Played \n by Various Audio Metrics") +
xlab("metric") + ylab("Not Skipped %") +
theme(plot.title = element_text(hjust = 0.5))
track_plays_skips_features %>%
select(
not_skipped_pct,
energy,
bounciness,
beat_strength,
danceability,
flatness,
instrumentalness,
speechiness,
acousticness,
liveness
) %>%
gather(key = metric_name, value = metric, -not_skipped_pct) %>%
ggplot(aes(x = metric, y = not_skipped_pct)) +
geom_point() +
facet_wrap(~metric_name) +
# Add an understandable plot title and clean axis labels
ggtitle("Percentage of Times each Track was Skipped of its Times Played \n by Various Audio Metrics") +
xlab("metric") + ylab("Not Skipped %") +
theme(plot.title = element_text(hjust = 0.5))
